# Output tagging

We first examine how input and output steps are roughly translated into TPTP formulas, then we describe the issue and the technique we used to resolve said issue.

We use process `R` in CH07 as an example. The top code block is from `CH07-tag-auth.pv`, the bottom code block is from `CH07-tag-auth.untagged.p`. Both files are in `examples/` in project repository's root folder.

```ocaml
let R =
  new r1:bitstring;
  out(c, (QUERY, r1));                  (* 1. send r1 R -> T *)
  in(c, (r2             : bitstring,
         left_xor_ID2_g : bitstring));  (* 2. recv left(xor(ID2, g))
                                           T -> R *)
  let g     = h(xor(xor(r1, r2), k)) in
  let ID2   = rotate(ID, g) in
  let left  = split_L(xor(ID2, g)) in
  let right = split_R(xor(ID2, g)) in
  if left = left_xor_ID2_g then (
    out(c, right);                      (* 3. send right(xor(ID2, g))
                                           R -> T *)
    (* authenticated, send out objective *)
    out(c, objective)
  ).
```

generates the following (only the most relevant ones are shown)

```ocaml
fof(ax121, axiom,
pred_attacker(tuple_2(constr_QUERY, name_r1))).

fof(ax122, axiom,
![VAR_R2_233] : (pred_attacker(tuple_2(VAR_R2_233, constr_split_L(constr_xor(constr_rotate(name_ID, constr_h(constr_xor(constr_xor(name_r1, VAR_R2_233), name_k))), constr_h(constr_xor(constr_xor(name_r1, VAR_R2_233), name_k)))))) => pred_attacker(constr_split_R(constr_xor(constr_rotate(name_ID, constr_h(constr_xor(constr_xor(name_r1, VAR_R2_233), name_k))), constr_h(constr_xor(constr_xor(name_r1, VAR_R2_233), name_k))))))).

fof(ax123, axiom,
![VAR_R2_235] : (pred_attacker(tuple_2(VAR_R2_235, constr_split_L(constr_xor(constr_rotate(name_ID, constr_h(constr_xor(constr_xor(name_r1, VAR_R2_235), name_k))), constr_h(constr_xor(constr_xor(name_r1, VAR_R2_235), name_k)))))) => pred_attacker(name_objective))).
```

We can see that the first `out` step which is an unconditional step is translated into a simple axiom stating attacker always knows this information.

The second and third `out` step are translated into implications, with the `in` step becoming the `premise`, `out` becoming the conclusion.

Since the output itself does not contain any information about steps, Vampire output also does not contain any information about steps as well. This is not an issue if the refutation proof is only used as a form of certificate, however, this makes analysis of the refutation proof more difficult. Specifically the following tasks are made more difficult for Narrator by not having information about steps

- Classification of FOF formulas into protocol steps (e.g. need to differentiate between an axiom with implication and the protocol step axiom)

- Extraction of attack trace (can't tell the step number or process initiating the step)

While having Narrator to be able to analyse both the ProVerif encoding and output solver might allow extraction of above information, tagging is much simpler.

We examine the tagged version of process `R` (copied from `CH07-tag-auth.pv.processed`). Formatting is different and comments are absent as this is a reexported copy generated by ProVerif using the `-log-pv` flag, but strucutre is the same.

```ocaml
const R_STEP_1 : bitstring.
const R_STEP_2 : bitstring.
const R_STEP_3 : bitstring.

let R =
  new r1 : bitstring;
  out(c, ((QUERY, r1), R_STEP_1));
  in(c, (r2 : bitstring, left_xor_ID2_g : bitstring));
  let g = h(xor(xor(r1, r2), k)) in
  let ID2 = rotate(ID, g) in
  let left = split_L(xor(ID2, g)) in
  let right = split_R(xor(ID2, g)) in
  
  if left = left_xor_ID2_g then
  out(c, (right, R_STEP_2));
  out(c, (objective, R_STEP_3));
  0.
```

We noticed each output steps now has an extra constant attached, forming a tuple.

- `out(c, (QUERY, r1))` becomes `out(c, ((QUERY, r1), R_STEP_1))`

- `out(c, right)` becomes `out(c, (right, R_STEP_2))`

- `out(c, objective)` becomes `out(c, (objective, R_STEP_3))`

The translated TPTP output (copied from `CH07-tag-auth.p`)

```
fof(ax226, axiom,
pred_attacker(tuple_2(tuple_2(constr_QUERY, name_r1), constr_R_STEP_1))).

![VAR_R2_281] : (pred_attacker(tuple_2(VAR_R2_281, constr_split_L(constr_xor(constr_rotate(name_ID, constr_h(constr_xor(constr_xor(name_r1, VAR_R2_281), name_k))), constr_h(constr_xor(constr_xor(name_r1, VAR_R2_281), name_k)))))) => pred_attacker(tuple_2(constr_split_R(constr_xor(constr_rotate(name_ID, constr_h(constr_xor(constr_xor(name_r1, VAR_R2_281), name_k))), constr_h(constr_xor(constr_xor(name_r1, VAR_R2_281), name_k)))), constr_R_STEP_2)))).

![VAR_R2_293] : (pred_attacker(tuple_2(VAR_R2_293, constr_split_L(constr_xor(constr_rotate(name_ID, constr_h(constr_xor(constr_xor(name_r1, VAR_R2_293), name_k))), constr_h(constr_xor(constr_xor(name_r1, VAR_R2_293), name_k)))))) => pred_attacker(tuple_2(name_objective, constr_R_STEP_3)))).
```

where we can see the tag attached to the output part of the formula.

And the tag is preserved in the solver output as well (copied from `CH07-tag-auth.solver_log`)

```ocaml
fof(f227,axiom,(
  pred_attacker(tuple_2(tuple_2(constr_QUERY,name_r1),constr_R_STEP_1))),
  file('CH07-tag-auth.p',unknown)).
  
fof(f229,axiom,(
  ! [X28] : (pred_attacker(tuple_2(X28,constr_split_L(constr_xor(constr_rotate(name_ID,constr_h(constr_xor(constr_xor(name_r1,X28),name_k))),constr_h(constr_xor(constr_xor(name_r1,X28),name_k)))))) => pred_attacker(tuple_2(name_objective,constr_R_STEP_3)))),
```

(step 2 disappeared as it's not relevant to the attack).

## Implementation

Above is implemented in

- `Pitsyntax.tag_outputs`, and is only used in transformation if `-tag-out` flag is provided to ProVerif
